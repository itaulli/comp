// This code illustrates correct mutex usage via the RAII idiom.
//
// TTU Computational Physics course (PHYS 4301/5322)
// I. Volobouev
// 02/04/2018

// To use threads, we must include the standard header file <thread>
#include <thread>

// To use mutex-based thread synchronization mechanisms, we must
// include the standard header file <mutex>
#include <mutex>

// Other standard headers needed for this example
#include <iostream>
#include <string>

// The following class is a functor -- it implements "operator()".
// C++ functors are similar in purpose to Python callables.
class Hello3
{
public:
    // Class constructor. The arguments "message" and "n"
    // will be stored internally and will be printed by
    // "operator()" defined next.
    Hello3(const std::string& message, const unsigned n)
        : message_(message), myNumber_(n) {}

    // Even though this class does not declare/define the copy
    // constructor and the assignment operator, these methods
    // will be automatically generated by the compiler

    // Our threads will call the following operator. "const"
    // after the method declaration means that this function
    // will not modify internal data members of this class.
    void operator()() const
    {
        // The code below shows the proper way of handling
        // a mutex. The variable "mutexGuard" is of type
        // "std::lock_guard<std::mutex>". When "mutexGuard"
        // is constructed, its constructor will call the "lock()"
        // function of "printMutex_" object. When "mutexGuard"
        // goes out of scope, it will be destructed, and the
        // destructor will call the "unlock()" function of
        // "printMutex_" object. Here, "mutexGuard" scope ends
        // where the function body ends, at the closing "}".
        //
        // If the code below runs as intended, its effect will be
        // the same as in hello2.cc:
        //
        // printMutex_.lock();
        // std::cout << message_ << " from " << myNumber_ << "!\n";
        // printMutex_.unlock();
        //
        // So, why do we need mutexGuard at all? This has to do
        // with the possibility that the code section protected
        // by the mutex might throw an exception. Imagine what
        // happens to the code snippet above if the exception is
        // thrown during the execution of "std::cout << message_"
        // statement. In this case the remaining part of the code
        // will not run, and the computer will never get to the
        // "printMutex_.unlock()" statement! The mutex will remain
        // locked forever, and no other threads will be able to run
        // this section of the code.
        //
        // On the other hand, the C++ exception handling mechanism
        // will perform the "stack unwinding" during which all
        // local objects will be properly terminated. "mutexGuard"
        // below is such an object, and its destructor will be
        // called even if the exception is encountered somewhere
        // inside the protected code section. The destructor will
        // thus unlock the mutex no matter what.
        //
        // One can think of a mutex lock as if it is a resource
        // acquired by the thread. This resource has to be properly
        // released no matter what happens. The technique of
        // releasing resources in destructors of special "guard"
        // objects has a special name: "Resource acquisition is
        // initialization", or RAII. For more information, see
        // https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization
        //
        // In Python, keyword "with" is used for similar purposes.
        //
        std::lock_guard<std::mutex> mutexGuard(printMutex_);
        std::cout << message_ << " from " << myNumber_ << "!\n";
    }

private:
    // The printMutex_ variable below will be shared by all
    // objects of this class, similar to class variables in Python.
    // Keyword "static" is used here to designate such variables.
    // Note that this keyword has such a meaning only inside class
    // declarations (outside of any class or function body it can
    // also be used to indicate "file scope").
    static std::mutex printMutex_;

    std::string message_;
    unsigned myNumber_;
};


// We have declared printMutex_ inside the Hello3 class, but it
// does not have a value! Here is the initialization (as opposed
// to declaration) of that variable. The statement below makes
// an object of std::mutex class using the default constructor
// of that class (the one that takes no arguments). This object
// will be made before the "main()" program runs.
std::mutex Hello3::printMutex_;


// This is the program code. Apart from replacing "Hello1" with "Hello3",
// it is identical to the hello1.cc example.
int main()
{
    // Create the threads. Upon creation, the threads
    // are immediately scheduled for execution. The thread
    // constructor arguments are functors whose "operator()"
    // methods will be run. The functors will be copied
    // (that is, their copy constructor will be invoked,
    // no matter whether explicitly coded or automatically
    // generated).
    std::thread t1{Hello3("Hello", 1)};
    std::thread t2{Hello3("Greetings", 2)};
    std::thread t3{Hello3("Hi", 3)};
    std::thread t4{Hello3("Bye-bye", 4)};

    // Wait until the threads run to completion. This is
    // performed by calling the "join" method of each thread.
    t1.join();
    t2.join();
    t3.join();
    t4.join();

    // We are done. Return value of 0 means success.
    return 0;
}
