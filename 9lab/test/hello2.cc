// This code illustrates basic mutex usage.
//
// TTU Computational Physics course (PHYS 4301/5322)
// I. Volobouev
// 02/04/2018

// To use threads, we must include the standard header file <thread>
#include <thread>

// To use mutex-based thread synchronization mechanisms, we must
// include the standard header file <mutex>
#include <mutex>

// Other standard headers needed for this example
#include <iostream>
#include <string>

// The following class is a functor -- it implements "operator()".
// C++ functors are similar in purpose to Python callables.
class Hello2
{
public:
    // Class constructor. The arguments "message" and "n"
    // will be stored internally and will be printed by
    // "operator()" defined next.
    Hello2(const std::string& message, const unsigned n)
        : message_(message), myNumber_(n) {}

    // Even though this class does not declare/define the copy
    // constructor and the assignment operator, these methods
    // will be automatically generated by the compiler

    // Our threads will call the following operator. "const"
    // after the method declaration means that this function
    // will not modify internal data members of this class.
    void operator()() const
    {
        // Calling the "lock()" member function of a mutex
        // (MUTual EXclusion) ensures that only one thread
        // will run the subsequent code, until the "unlock()"
        // function is called. Here, we ensure that the program
        // standard output is used by one thread at a time.
        printMutex_.lock();
        std::cout << message_ << " from " << myNumber_ << "!\n";
        printMutex_.unlock();
    }

private:
    // The printMutex_ variable below will be shared by all
    // objects of this class, similar to class variables in Python.
    // Keyword "static" is used here to designate such variables.
    // Note that this keyword has such a meaning only inside class
    // declarations (outside of any class or function body it can
    // also be used to indicate "file scope").
    static std::mutex printMutex_;

    std::string message_;
    unsigned myNumber_;
};


// We have declared printMutex_ inside the Hello2 class, but it
// does not have a value! Here is the initialization (as opposed
// to declaration) of that variable. The statement below makes
// an object of std::mutex class using the default constructor
// of that class (the one that takes no arguments). This object
// will be made before the "main()" program runs.
std::mutex Hello2::printMutex_;


// This is the program code. Apart from replacing "Hello1" with "Hello2",
// it is identical to the hello1.cc example.
int main()
{
    // Create the threads. Upon creation, the threads
    // are immediately scheduled for execution. The thread
    // constructor arguments are functors whose "operator()"
    // methods will be run. The functors will be copied
    // (that is, their copy constructor will be invoked,
    // no matter whether explicitly coded or automatically
    // generated).
    std::thread t1{Hello2("Hello", 1)};
    std::thread t2{Hello2("Greetings", 2)};
    std::thread t3{Hello2("Hi", 3)};
    std::thread t4{Hello2("Bye-bye", 4)};

    // Wait until the threads run to completion. This is
    // performed by calling the "join" method of each thread.
    t1.join();
    t2.join();
    t3.join();
    t4.join();

    // We are done. Return value of 0 means success.
    return 0;
}
